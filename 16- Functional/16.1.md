# Functional Java

Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. Java has introduced functional programming features in Java 8, such as lambda expressions, functional interfaces, streams, and more.

## 0. Differences Between Functional and Imperative Programming

- **Imperative Programming**: In imperative programming, the focus is on **how** to perform a task. It uses statements to change the program's state.
- **Functional Programming**: In functional programming, the focus is on **what** to perform. It uses expressions to evaluate functions and avoid changing the program's state. It is **declarative**.

```java

// Imperative Programming (Steps to perform the task)
int sum = 0;
for (int i = 1; i <= 10; i++) {
    sum += i;
}
System.out.println(sum);

// Functional Programming (What to perform - Declarative)
int sum = IntStream.rangeClosed(1, 10).sum();
System.out.println(sum);

```

## 1. Functional Interface

A functional interface is an interface that contains **only one abstract method**.

```java

@FunctionalInterface
interface MyFunctionalInterface {
    void myMethod();
}

```

## 2. Lambda Expression

A lambda expression is a short block of code that takes in parameters and returns a value. It is similar to a method, but it doesn't need a name. It is used to provide the implementation of a functional interface.

Example 1

```java

MyFunctionalInterface myFunctionalInterface = () -> {
    // Implementation of the abstract method to print "Hello"
    System.out.println("Hello");
    System.out.println("World");
};

myFunctionalInterface.myMethod();

```

## 3. Method & Constructor Reference

### 1. Method Reference

A method reference is used to refer to a method without invoking it. It is similar to a lambda expression, but it provides a way to reuse an existing method implementation.

```java

Function<Integer, Integer> square = Math::square;
// Function<Integer, Integer> square = i -> i * i;

```

Example Usage:

```java

List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(System.out::println);
// names.forEach(name -> System.out.println(name));

```

### 2. Constructor Reference

A constructor reference is used to refer to a constructor without instantiating it. It is similar to a method reference, but it provides a way to reuse an existing constructor implementation.

```java

Supplier<MyFunctionalInterface> supplier = MyFunctionalInterface::new;
// Supplier<MyFunctionalInterface> supplier = () -> new MyFunctionalInterface();

```

## 4. Lambda Scopes

Lambda expressions can access **final** or **effectively final** variables from the enclosing scope.

```java


```

The variable `x` is effectively final, as the JVM treats it as final even if it is not explicitly declared as final. If you try to modify the value of `x`, it will result in a compilation error.

## 5. JDK Functional Interfaces

### 1. Predicate

A `Predicate` is a functional interface that represents a boolean-valued function of one argument. It is used to test a condition.

```java

Predicate<Integer> isPositive = i -> i > 0;

```

#### What if I want a predicate that takes two arguments?

You can use the `BiPredicate` interface, which represents a predicate that takes two arguments.

```java

BiPredicate<Integer, Integer> isGreater = (a, b) -> a > b;

```

### 2. Function

A `Function` is a functional interface that represents a function that takes one argument and returns a result.

```java

Function<Integer, Integer> square = i -> i * i;

```

#### What if I want a function that takes two arguments?

You can use the `BiFunction` interface, which represents a function that takes two arguments and returns a result.

```java

BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

```

### 3. Consumer

A `Consumer` is a functional interface that represents an operation that accepts a single input argument and returns no result.

```java

Consumer<Integer> print = i -> System.out.println(i);

```

### 4. Supplier

A `Supplier` is a functional interface that represents a supplier of results.

```java

Supplier<Integer> random = () -> new Random().nextInt();

```

### 5. UnaryOperator

A `UnaryOperator` is a functional interface that represents an operation on a single operand that produces a result of the same type as its operand.

```java

UnaryOperator<Integer> square = i -> i * i;
// Function<Integer, Integer> square = i -> i * i;

```

### 6. BinaryOperator

A `BinaryOperator` is a functional interface that represents an operation upon two operands of the same type, producing a result of the same type as the operands.

```java

BinaryOperator<Integer> add = (a, b) -> a + b;
// BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

```

## 8. Stream

A `Stream` is a sequence of elements supporting sequential and parallel aggregate operations.

```java

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().filter(i -> i % 2 == 0).forEach(System.out::println);

```

## 10. Optional

An `Optional` is a container object that may or may not contain a non-null value. It is used to represent the presence or absence of a value.

```java

Optional<Integer> optional = Optional.of(1);
optional.ifPresent(System.out::println);

```

## 11. CompletableFuture

A `CompletableFuture` is used for asynchronous programming in Java. It represents a future result of an asynchronous computation.

```java

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 1);

```

## 12. Functional Programming

Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.

```java

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, Integer::sum);

```

## 13. Map, Filter, and Reduce

Map, filter, and reduce are common functional programming operations that are used to transform, select, and aggregate data.

### Map

```java

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream().map(i -> i * i).collect(Collectors.toList());

// Output: [1, 4, 9, 16, 25]

```

### Filter

```java

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evens = numbers.stream().filter(i -> i % 2 == 0).collect(Collectors.toList());

// Output: [2, 4]

```

### Reduce

```java

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, Integer::sum);

// Output: 15

```
